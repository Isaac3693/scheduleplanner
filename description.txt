What does this do?

It creates an application that plans your day without having to write things down.

struct tm details

  struct tm {
    int tm_sec;
    int tm_min; (0 - 59) is minute.
    int tm_hour; (uses military time)
    int tm_mday; (1st day of month = 31)
    int tm_mon; (Jan = 0, Dec = 11)
    int tm_year; (2023 = 123, => years since 1900)
    int tm_wday;
    int tm_yday;
    int tm_isdst;
  };

LIBRARY FILES

schedulestructs.h
timeslot.c (contains methods for the day)
scheduledDays.c (contains methods for the queue containing all scheduled days)
(insert name of file dealing with string parsing)
(A huge ass file containing the control flow of the program, aka main.c)

PROBLEMS AND POTENTIAL BUGS
  (FIXED)
  In date_delete_timeslot_from_date() function, any timeslot can have the same name, meaning that the search for a specific timeslot will be 
    ambiguous and will most likely delete the first item in the linked list that the iteration reaches first. SOLUTION: Change the function such that
    it either asks for the starting time or the end time or implement an id (I think the former sounds like a better idea) 

  date_print_date() function, it seems like the minute integers aren't really integers and 
    SOLUTION: I forgot to assign the variables, dumbass.



EXAMPLE TEXT FILE--------------------------

11-29-2023
6AM TO 7:30AM: Make Breakfast
7:30AM to 9:30 AM: Make project
9:30AM to ...
9:00PM to 12:00AM: sleep

11-30-2023
...

--------------------------------------------

DATA STRUCTURES & METHODS
  day: acts like a linked list containing nodes (timeslots)
  scheduled_days: a queue containing day nodes

  IDEA: all functions take the memory address of the day and would act like error checking. (fuck)
  ISSUES:
    timeslots wouldn't be organized by time (make a method to organize them)
      Solution: days should contain a timeslot dynamic array and
      should have a size_t variable counting the cardinality of the set.
      And then use a mergesort algorithm for every time the user finishes 
      setting up a date.

      user enters data into a temporary txt file,
        use a linked list to keep track of the 

    ()new slot 8:00 10:00 name
    //After input:
      go through the list and see if there is a timeslot occupying 
      the interval.
      if current timeslot covers the newly inputted timeslot, 
        throw a warning at the user saying that they need to edit a timeslot.
        if hour[i] == this.hour {
            if min[i] > this.min throw warning
            //alternative, if (min[i] - this.min !=)
        }



./planner.exe <name_of_file> //MUST BE TXT

ON_LOAD
    -Check the number of schedules printed in the list
    -//Should I use a dynamic array of struct tms or a linked list? (what about a queue?)
    -return data structure after reading the file
    -


USER COMMANDS

()today
    prints the schedule for today
()tmrw
    prints the schedule for tomorrow
()week
    prints the schedule for the 7 days

//check if there is already a schedule for that date
()create_schedule <date> 
    ()add <time-start> <time-end> <name_of_task>
    ()del <name_of_task>
    ()show_schedule
    ()save //quitting the schedule essentially

()edit_schedule <date>
    //same commands as create_schedule

()delete_schedule <date>

()



/*

    Pseudocode for the append/enqueue function 

    Is the main head NULL? Then assign the day to the head & return.

    Does the head come after the day? Then assign the head to the day and assign the new head's pointer to the old head & return.
    
    /At this point it is clear that the day is the same as the head or later

    If the dates are the same, then return 1. 

    /Now the day comes after the head

    Does the head have a next pointer that is NULL? If so, then assign that pointer to the day & return.

    /Now we start the iteration.

    for each i in the list and j that precedes i so long as i isn't null

    Does date i come after day?
      Does j come before day? /If it comes after, then that means that on the iteration in which i was the current j index, this meant that it failed to do what it was originally intended to do/ If so then day comes between i and j & return. If j is equal to day, return 1/


    If i's next is NULL and day comes after i, then assign i's next to day.

    /END FOR LOOP



*/
